generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ---------------------------------------------------------
// ENUMS
// ---------------------------------------------------------

enum Role {
  USER
  ADMIN
  SUPERADMIN
}

enum MatchStatus {
  PENDING   // Waiting for opponent confirmation
  ACCEPTED  // Challenge accepted, waiting to be played
  VALIDATED // Confirmed and counted towards ELO
  REJECTED  // Declined by opponent
}

// ---------------------------------------------------------
// MODELS
// ---------------------------------------------------------

model Organization {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  inviteCode  String   @unique
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  members     OrganizationMember[]
  matches     Match[]
  tournaments Tournament[]

  @@map("organizations")
}

model OrganizationMember {
  id             String       @id @default(cuid())
  userId         String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  role           Role         @default(USER)
  elo            Int          @default(1200)
  joinedAt       DateTime     @default(now())

  @@unique([userId, organizationId])
  @@map("organization_members")
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  password      String?   // For credentials authentication
  
  // Profile
  bio           String?   @db.Text
  avatarUrl     String?
  
  // Security & Permissions
  role          Role      @default(USER)
  globalRole    String?   @default("USER")
  
  // Stats
  elo           Int       @default(1200)
  
  // Timestamps
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relationships
  matchesAsPlayer1   Match[]  @relation("Player1")
  matchesAsPlayer2   Match[]  @relation("Player2")
  matchesWon         Match[]  @relation("Winner")
  
  createdTournaments Tournament[] @relation("TournamentCreator")
  participations     TournamentParticipant[]
  
  // Bracket relations
  bracketAsPlayer1   BracketMatch[] @relation("BracketPlayer1")
  bracketAsPlayer2   BracketMatch[] @relation("BracketPlayer2")
  bracketWins        BracketMatch[] @relation("BracketWinner")
  
  rankingLogs        RankingLog[]
  
  // User settings (colors, preferences)
  settings           UserSettings?
  
  // Organization memberships
  memberships        OrganizationMember[]

  @@map("users")
}

model UserSettings {
  id              String   @id @default(cuid())
  
  userId          String   @unique
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Color preferences
  primaryColor    String   @default("#6366f1")   // indigo-500
  secondaryColor  String   @default("#8b5cf6")   // purple-500
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@map("user_settings")
}

model Match {
  id          String       @id @default(cuid())
  
  // Organization scope
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  
  // Metadata
  playedAt    DateTime     @default(now())
  status      MatchStatus  @default(PENDING)
  
  // Participants
  player1Id   String
  player1     User         @relation("Player1", fields: [player1Id], references: [id])
  
  player2Id   String
  player2     User         @relation("Player2", fields: [player2Id], references: [id])
  
  // Result
  winnerId    String?
  winner      User?        @relation("Winner", fields: [winnerId], references: [id])
  
  // Score details (Best of 3 sets usually)
  games       Game[]

  // Optional Context
  tournamentId String?
  tournament   Tournament? @relation(fields: [tournamentId], references: [id])

  // Auditing for ELO changes
  rankingLogs RankingLog[]

  // Deletion approval tracking (for verified matches)
  deletionRequestedBy String?
  
  // Adjustment approval tracking
  adjustmentRequest   Json?        // Stores { newScores, newOpponentId, type: 'UPDATE' }

  // Friendly match (no ELO impact)
  isValidated   Boolean      @default(true)  // false = friendly/practice match

  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  @@index([player1Id])
  @@index([player2Id])
  @@index([winnerId])
  @@index([status])
  @@index([organizationId])
  @@map("matches")
}

model Game {
  id             String   @id @default(cuid())
  
  matchId        String
  match          Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  
  setNumber      Int      // e.g., 1, 2, 3
  
  scorePlayer1   Int
  scorePlayer2   Int

  @@unique([matchId, setNumber]) // Cannot have two "Set 1"s in the same match
  @@map("games")
}

model Tournament {
  id          String   @id @default(cuid())
  name        String
  description String?  @db.Text
  
  // Organization scope
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  
  startDate   DateTime
  endDate     DateTime
  maxParticipants Int @default(32)
  
  // Bracket settings
  bracketGenerated Boolean @default(false)
  seedingType      String  @default("RANDOM") // RANDOM or ELO
  
  creatorId   String
  creator     User     @relation("TournamentCreator", fields: [creatorId], references: [id])
  
  participants TournamentParticipant[]
  matches      Match[]
  bracketMatches BracketMatch[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([organizationId])
  @@map("tournaments")
}

model TournamentParticipant {
  id           String     @id @default(cuid())
  
  tournamentId String
  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  
  userId       String
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  seed         Int?       // Seeding position (1 = top seed)
  
  joinedAt     DateTime   @default(now())

  @@unique([tournamentId, userId]) // User can only join a tournament once
  @@map("tournament_participants")
}

model RankingLog {
  id        String   @id @default(cuid())
  
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  matchId   String?
  match     Match?   @relation(fields: [matchId], references: [id])
  
  // Organization scope (for filtering history)
  organizationId String?
  
  eloBefore Int
  eloAfter  Int
  change    Int      // e.g. +15 or -12
  
  createdAt DateTime @default(now())

  @@index([userId])
  @@map("ranking_logs")
}

model BracketMatch {
  id            String     @id @default(cuid())
  
  tournamentId  String
  tournament    Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  
  round         Int        // 1 = first round, 2 = quarters, etc.
  position      Int        // Position in round (0-indexed)
  
  player1Id     String?
  player1       User?      @relation("BracketPlayer1", fields: [player1Id], references: [id])
  
  player2Id     String?
  player2       User?      @relation("BracketPlayer2", fields: [player2Id], references: [id])
  
  winnerId      String?
  winner        User?      @relation("BracketWinner", fields: [winnerId], references: [id])
  
  score1        Int?       // Games won by player1
  score2        Int?       // Games won by player2
  
  status        String     @default("PENDING") // PENDING, PLAYED, BYE
  
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  @@unique([tournamentId, round, position])
  @@map("bracket_matches")
}

